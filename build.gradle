apply plugin: 'properties'
apply plugin: 'git-dependencies'

project.description = "CableLabs CVP2 installer"

buildscript {
    ext {
        clCredentials = {
            username "${cl_repo_user}"
            password "${cl_repo_password}"
        }    
        repoConfig = {
            maven {
                url "https://community.cablelabs.com/mvn/cvp2ri-repo"
                credentials clCredentials
            }
        }
    }

    repositories repoConfig
    
    dependencies {
        classpath(group: 'net.saliman', name: 'gradle-properties-plugin', version: '1.1.1')
        classpath(group: 'org.batcha.gradle.plugins', name: 'git-dependencies', version: '0.1.2')    
    }
}

repositories repoConfig

if (new File('build-local.gradle').exists()) {
    apply from: 'build-local.gradle'
}

ext.full_base_path="${System.env.HOME}/${base_path}"
ext.prefix_path="${full_base_path}/${install_dirname}"

project.gitDependenciesDir = "${full_base_path}/${source_dirname}"

task description {
    description = 'Display project information'
    println "Description:   ${project.description}"

    println ""
    println "Initial setup (using the provided Gradle wrapper)."
    println "If Gradle is installed manually, replace './gradlew' with 'gradle':"
    println ""
    println "1. Copy and paste the output of the following command:"
    println "./gradlew showPkgCommand"
    println ""
    println "2. Install third-party component dependencies:"
    println "./gradlew installDependencies"
    println ""
    println "3. Install git components:"
    println "./gradlew install"
    println ""
    println "4. Generate env_setup script:"
    println "./gradlew generateEnvSetup"
    println ""
    println ""
    println "To build and install an individual subproject without building dependencies:"
    println "./gradlew -p {project} install -Pskipdeps"
    println ""
}

task installDependencies (dependsOn: ":external:installAll") << { println "Dependencies installed" }

task showPkgCommand (dependsOn: ":external:showPkgCommand")

List getProperties (Project project, String context, String propertyName) {
    def outputs = []
    def propertyNameToUse
    if (project.hasProperty(context + propertyName)) {
        propertyNameToUse = context + propertyName
    } else if (project.hasProperty("default" + propertyName)) {
        propertyNameToUse = "default" + propertyName
    } else {
        return outputs
    }
    
    def line = project.getProperty(propertyNameToUse)
    outputs = line.split(" ").collect{it.trim()}
    return outputs
}

List getPathProperties (Project project, String directoryPrefix, String context, String propertyName) {
    def outputs = []
    def propertyNameToUse
    if (project.hasProperty(context + propertyName)) {
        propertyNameToUse = context + propertyName
    } else if (project.hasProperty("default" + propertyName)) {
        propertyNameToUse = "default" + propertyName
    } else {
        return outputs
    }
    
    def line = project.getProperty(propertyNameToUse)
    outputs = line.split(" ").collect{directoryPrefix + '/' + it.trim()}
    return outputs
}

Closure configEnv = {
    def destination = "${prefix_path}"
    def pkgConfigPath = "${destination}/lib/pkgconfig:${destination}/share/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig:/usr/lib/i386-linux-gnu/pkgconfig:/usr/lib/x86_64-linux-gnu/pkgconfig"
    def ldLibraryPath="${destination}/lib"
    def xdgDataDirs = "${destination}/share" 
    def envVars = [:]
    envVars['CVP2_ROOT'] = "${destination}"
    envVars['PKG_CONFIG_PATH'] = "${System.env.PKG_CONFIG_PATH}" != "null" ? "${System.env.PKG_CONFIG_PATH}:${pkgConfigPath}" : "${pkgConfigPath}"
    envVars['ACLOCAL_FLAGS'] = "-I /usr/share/aclocal -I ${destination}/share/aclocal"
    envVars['CFLAGS'] = "-I${destination}/include"
    envVars['CPPFLAGS'] = "-I${destination}/include"
    envVars['LDFLAGS'] = "-L${destination}/lib"
    envVars['LD_LIBRARY_PATH'] = "${System.env.LD_LIBRARY_PATH}" != "null" ? "${System.env.LD_LIBRARY_PATH}:${ldLibraryPath}" : "${ldLibraryPath}"
    envVars['PKG_CONFIG_LIBDIR'] = "${destination}/lib/pkgconfig"
    envVars['PATH'] = "${destination}/bin:${System.env.PATH}"
    envVars['XDG_DATA_DIRS'] = "${System.env.XDG_DATA_DIRS}" != "null" ? "${System.env.XDG_DATA_DIRS}:${xdgDataDirs}" : "${xdgDataDirs}"
    return envVars
}

boolean checkDisabled(String projectName) {
    if (project.getProperty("gst_uninstalled_core") == "true" &&
            ((projectName == "gstreamer") || 
            (projectName == "gst-plugins-base") ||
            (projectName == "gst-plugins-good") || 
            (projectName == "gst-plugins-bad") ||
            (projectName == "gst-plugins-ugly") ||
            (projectName == "gst-libav"))) { 
        return true; 
    }
    if (project.getProperty("gst_uninstalled_dlnasrc") == "true" && projectName == "gst-plugins-dlnasrc") {
        return true; 
    }
    if (project.getProperty("gst_uninstalled_dtcpip") == "true" && projectName == "gst-plugins-dtcpip") {
        return true; 
    }
    return false;
}

task generateEnvSetup << {
    def f = new File("${full_base_path}/env_setup")
    if (!f.exists()) {
        def entries = configEnv()
        entries.each {
            f.append('export ' + it.key + '="' + it.value + '"' + System.getProperty("line.separator"))
        }
        println "Generated env setup file: " + f + " - to use, source the file"
    } else { 
        println "The env setup file already exists at: " + f + " - not generating"
    }
}

configurations {
    git
}

configure(subprojects.findAll {it.name != 'external'}) {
    if (new File('build-local.gradle').exists()) {
        apply from: 'build-local.gradle'
    }

    project.description = description

    if (checkDisabled(it.name)) {
        println "Not building ${project.name}"
    } else {
        if (!new File("${gitDependenciesDir}/${project.name}").exists())     {
            println "Adding ${project.name} Git dependency - will clone git remote: ${checkout_url} branch: ${checkout_branch} into ${gitDependenciesDir}/${project.name}"
            println ""
            dependencies {
                rootProject.dependencies.git("com.cablelabs.cvp2:${project.name}:${checkout_branch}").ext.git = "${checkout_url}"
            }
        }
    }

    task "configure" (type: Exec) {
        ext.directory = "${gitDependenciesDir}/${project.name}"
        //println "configure - directory: " + directory
        inputs.files getPathProperties(project, directory, project.name, "_configure_inputname")
        outputs.files getPathProperties(project, directory, project.name, "_configure_outputname")
        workingDir directory
        executable project.getProperty("gst_uninstalled_core") == "true" ? "gst-git" : "${configure_command}"

        List arguments = []
        if (project.getProperty("gst_uninstalled_core") == "true") {
            arguments << "${configure_command}"
        }
        arguments << "--prefix=${prefix_path}"
        def extraArguments = getProperties(project, project.name, "_configure")
        if (extraArguments.size() > 0) {
            arguments.addAll(extraArguments)
        }
        args arguments
        environment (configEnv())
    }

    task "make" (type: Exec, dependsOn:configure) {
        ext.directory = "${gitDependenciesDir}/${project.name}"
        //println "make - directory: " + directory
        workingDir directory
        executable project.getProperty("gst_uninstalled_core") == "true" ? "gst-git" : "make"

        List arguments = []
        if (project.getProperty("gst_uninstalled_core") == "true") {
            arguments << "make"
        }
        args arguments
        environment (configEnv())
    }

    task removeLaFiles << {
        def filesToRemove = getProperties(project, "", "post_install_remove_la_files")
        filesToRemove.each {
            new File("${prefix_path}/" + it).delete();
        }
    }

    task "install" (type: Exec, dependsOn:make) {
        ext.directory = "${gitDependenciesDir}/${project.name}"
        //println "make install - directory: " + directory
        workingDir directory
        executable project.getProperty("gst_uninstalled_core") == "true" ? "gst-git" : "make"

        List arguments = []
        if (project.getProperty("gst_uninstalled_core") == "true") {
            arguments << "make"
        }
        arguments << "install"
        args arguments
        environment (configEnv())
    }

    task "clean" (type: Exec) {
        ext.directory = "${gitDependenciesDir}/${project.name}"
        //println "make clean - directory: " + directory
        workingDir directory
        executable project.getProperty("gst_uninstalled_core") == "true" ? "gst-git" : "make"

        List arguments = []
        if (project.getProperty("gst_uninstalled_core") == "true") {
            arguments << "make"
        }
        arguments << "clean"
        args arguments
        environment (configEnv())
        ignoreExitValue true
    }

    task "uninstall" (type: Exec) {
        ext.directory = "${gitDependenciesDir}/${project.name}"
        //println "make uninstall - directory: " + directory
        workingDir directory
        executable project.getProperty("gst_uninstalled_core") == "true" ? "gst-git" : "make"

        List arguments = []
        if (project.getProperty("gst_uninstalled_core") == "true") {
            arguments << "make"
        }
        arguments << "uninstall"
        args arguments
        environment (configEnv())
        ignoreExitValue true
    }

    install.finalizedBy removeLaFiles
    configure.enabled = !checkDisabled(it.name)
    make.enabled = !checkDisabled(it.name)
    install.enabled = !checkDisabled(it.name)
    clean.enabled = !checkDisabled(it.name)
    removeLaFiles.enabled = (project.getProperty("gst_uninstalled_core") == "true")

    if (!project.hasProperty('skipdeps')) {
        def dependencyNames = getProperties(project, "", "configure_deps")
        dependencyNames.each { String dependency ->
            configure.dependsOn{":${dependency}:install"}
            configure.mustRunAfter{":${dependency}:removeLaFiles"}
        }
    }
}

